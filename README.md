# K8s Deployment using Terraform
# Project Requirements
1. Create Terraform infra-as-code template for AWS/GCP, that can create:
    * VPC with private subnets in 3 different AZs, having NAT
    * Route53 zone
    * K8s cluster
    * Services running in the K8s cluster:
        * Statefulset: MySQL (DB)
        * Deployment: Apache + PHP (backend) serving simple 'Hello world' program, HPA: 3-12
        * Deployment: Nginx web-service (frontend) proxying requests to Tomcat
        * DNS: external-dns service that registers K8s services in Route53 automatically
2. Access to db ports has to be allowed from backend pods only
# Setup
The framework comprises of two folders k8s-yaml-config and terraform-k8s
1. **k8s-yaml-config**
    * This folder defines the following:
        * Creates and runs a sample hello backend microservice using a Deployment object
        * Uses a Service object to send traffic to the backend microservice's multiple replicas
        * Creates and runs a nginx frontend microservice, also using a Deployment object
        * Configures the frontend microservice to send traffic to the backend microservice
        * Use a Service object of type=LoadBalancer to expose the frontend microservice outside the cluster
    * **Creating the backend using a Deployment**
        * The backend is a simple hello greeter microservice
        * The deployment object can be created using the command
        ```bash
        kubectl apply -f backend-deployment.yaml
        ```
    * **Creating the hello service object**
        * The key to sending requests from a frontend to a backend is the backend Service
        * A Service creates a persistent IP address and DNS name entry so that the backend microservice can always be reached
        * A Service uses selectors to find the Pods that it routes traffic to
        * Create the backend Service:
        ```bash
        kubectl apply -f backend-service.yaml # the service object is defined in the deployment file, so this command needn't be run separately
        ```
    * **Creating the frontend**
        * The frontend sends requests to the backend worker Pods by using the DNS name given to the backend Service
        * The DNS name is ```hello```, which is the value of the ```name``` field in the ```backend-service.yaml``` configuration file
        * The Pods in the frontend Deployment run a nginx image that is configured to proxy requests to the ```hello``` backend Service
        * Create the frontend deployment and service:
        ```bash
        kubectl apply -f frontend-service.yaml  # the service object is defined in the deployment file, so this command needn't be run separately
        kubectl apply -f frontend-deployment.yaml
        ```
    * **Interact with the frontend Service**
        * Once you've created a Service of type LoadBalancer, you can use this command to find the external IP:
        ```bash
        kubectl get svc frontend --watch
        ```
        * This displays the configuration for the ```frontend``` Service and watches for changes
        * As soon as the external IP is provisioned, the ```frontend``` service can be accessed from outside the cluster
    * **Send traffic through the frontend**
        * The frontend and backend are now connected. You can hit the endpoint by using the curl command on the external IP of your frontend Service
        ```bash
        curl http://${EXTERNAL_IP} # replace this external IP with the IP provisioned by the cluster
        ```
        * The output shows the message generated by the backend:
        ```bash
        {"message":"Hello"}
        ```
    * **Network Policies**
        * Access to db ports is provided from the backend pod using network policies.
        Use the command:
        ```bash
        kubectl apply -f network-policies.yaml
        ```
    * **Cleaning up**
        * To delete the services, enter this command:
        ```bash
        kubectl delete services frontend backend
        ```
        * To delete the deployments, replicasets, and the pods that are running the frontend and backend applications, enter this command:
        ```bash
        kubectl delete deployments frontend backend
        ```
2. **terraform-k8s**
* Terraform is an open-source IaC tool
* Instead, of writing the code to create the infrastructure, you define a plan of what you want to be executed, and you let Terraform create the resources on your behalf
* But let's take a break from the theory and see those concepts in practice
* Before you can create a cluster with Terraform, you should install the binary
* Download Terraform for linux [terraform]https://releases.hashicorp.com/terraform/0.13.5/terraform_0.13.5_linux_amd64.zip from the highlighted link
* Verify that the Terraform tool has been installed correctly with:
```bash
terraform version
```
* To initalize terraform, run the command
```bash
terraform init
```
* This command will initialize Terraform and create two more folders as well as a state file
* **The state file is used to keep track of all the resources that have been created already**
* Consider this as a checkpoint, without it Terraform won't know what has been already created or updated
* There is another command that you can utilize in your undertaking with Terraform
* To quickly check if the configuration doesn't have any configuration errors you can do so with:
```bash
terraform validate
```
* Next, you should run:
```bash
terraform plan
```
* Terraform will then perform a dry-run and will prompt you a detailed summary of what resources is about to create
* If you feel confident that everything looks fine, you can create the resources with:
```bash
terraform apply # you will be asked to confirm your choices --- just type yes
```
* The process takes about 20 minutes to provision all the resources
* When its complete, if you inspect the current folder 
```bash
tree .
.
|---- kubeconfig_my-cluster
|---- vpc-eks.tf # the file present inside 1-infrastructure
|---- terraform.tfstate
|---- terraform.tfstate.backup
```
* ```terraform.tfstate``` and  ```terraform.tfstate.backup``` are the two files used by terraform to keep track of what resources were created
* The ```kubeconfig_my-cluster``` is the kubeconfig for the newly created cluster
* You can test the connection with the cluster by using that file with:
```bash
$ KUBECONFIG=./kubeconfig_my-cluster kubectl get pods --all-namespaces
```
* This command would list down the default namespaces with all the pods created in the default namespace
* Now that you've created the cluster, it's time to go back and discuss the terraform file
* **vpc-eks.tf** 
    * The first block is **the VPC module**
        * A VPC
        * Three public and private subnets
        * A single NAT gateway
        * **Tags for the subnets**
    * 
